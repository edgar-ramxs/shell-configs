#!/bin/sh

#     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
#     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù
#     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë        ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
#     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë        ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë
#  ‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë     ‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë
#  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù      ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù   ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

# ============================================================================
# FUNCIONES LIGERAS - Cargadas directamente en el inicio
# ============================================================================

function hydra() {
  # Muestra un arte ASCII animado de Hydra
  # Uso: hydra
  # Efecto: Limpia pantalla, muestra arte ASCII, espera una tecla
  clear &&
  echo \
  "    ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢§‚°Ä‚†Ä‚†∞‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚£†‚£§‚£Ä‚£Ä‚£Ä‚£Ä‚°Ä‚†Ä‚¢Ä‚£†‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚††‚†ê‚†í‚£í‚£≤‚£∂‚£¶‚£Ω‚£¶‚£Ä‚¢∑‚°Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†õ‚†õ‚¢ø‚£ø‚£∂‚£Ω‚£ø‚£ø‚£Ø‚£•‚£Ä‚°Ä‚†Ä‚†Ä‚†Ä‚£†‚£∂‚£ø‚£ø‚†ø‚†ü‚†ø‚¢ø‚£ø‚£ø‚£∂‚£Ñ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚†ª‚†õ‚†â‚†ô‚†ª‚£ø‚£ø‚£∂‚£ç‚†Ä‚†ä‚¢±‚£ø‚£ø‚£ø‚°á‚†Ä‚†Ä‚†Ä‚†Ä‚†à‚£ø‚£ø‚£∂‚£Ω‚£Ü‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†∏‚£ø‚£ø‚£Ø‚°ë‚†Ä‚¢∏‚£ø‚£ø‚£ø‚£ø‚°Ñ‚†Ä‚†Ä‚†Ä‚¢Ä‚†ô‚†õ‚†ø‚£ø‚£ø‚£¶‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚¢Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚£æ‚£ø‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†à‚†î‚†ö‚£ª‚£ø‚£ø‚£¶‚£§‚£Ä‚£à‚£≤‚£§‚£Ä‚£Ä‚°Ä‚†õ‚†É‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚¢†‚£á‚£¥‚£Æ‚£•‚£§‚°Ä‚†Ä‚¢∏‚£ø‚£ø‚°è‚†è‚†Ä‚†Ä‚†Ä‚£†‚£æ‚£ø‚£ø‚°ø‚†ü‚¢ø‚£ø‚£ø‚£Ü‚†à‚¢ø‚£ø‚†ø‚†ø‚†ø‚†ø‚£ø‚†Ä‚†Ä‚†Ä
‚†Ä‚£†‚¢ø‚£ø‚°ø‚†Ü‚†Ä‚¢∏‚£ø‚£ø‚£ß‚†â‚£ø‚£ø‚£∑‚°Ä‚†Ä‚†Ä‚¢†‚£ø‚£ø‚£ø‚£ß‚°Ä‚†Ä‚¢Ä‚£ø‚£ø‚£ø‚†Ä‚††‚†Ñ‚£Ä‚†Ä‚°Ü‚†Ä‚†Ä‚†Ä‚†Ä
‚¢Ä‚£Ø‚£æ‚°ø‚†Ü‚†Ä‚¢∏‚£ø‚£ø‚£ß‚†â‚£ø‚£ø‚£∑‚°Ä‚†Ä‚†Ä‚¢è‚†ª‚£ø‚£ø‚£ø‚£Ü‚£º‚£ø‚£ø‚£ø‚¢Ä‚£∫‚£ø‚£ø‚†Å‚†à‚£ø‚£∑‚£∑‚°Ä‚†Ä‚†Ä
‚£ø‚°ü‚†Å‚†Ä‚†Ä‚†Ä‚£æ‚£ø‚£ø‚†ª‚†Ä‚†ò‚¢ø‚£ø‚£ø‚£¶‚°Ä‚†Ä‚¢è‚†ª‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚°ø‚†Ä‚°ø‚£ø‚£ø‚£Ñ‚†Ä‚†Ä‚†à‚†π‚°ø‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢∏‚£ø‚£ø‚£á‚†Å‚†Ä‚†Ä‚†Ä‚†ô‚¢ø‚£ø‚£ø‚£∑‚£Æ‚£Ñ‚£π‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚†É‚†Ä‚†ò‚¢π‚£ø‚£ø‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚¢ø‚£ø‚£ø‚£¶‚£Ñ‚£Ä‚†Ä‚†Ä‚†Ä‚†ò‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£É‚£Ä‚£†‚£¥‚£ø‚£ø‚†è‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä
    ‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†≤‚£æ‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ø‚£ª‚†Ö‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä‚†Ä"
  tput civis
  read -n 1
  tput cnorm
}

function message() {
    local signal color
    local RESETC="\033[0m\e[0m"
    case "$1" in
        "-title")       color="\033[0;37m\033[1m";      signal="[$]"; shift; echo -e "${color}${signal} $*${RESETC}";;
        "-subtitle")    color="\033[0;35m\033[1m";      signal="[*]"; shift; echo -e "${color}${signal} $*${RESETC}";;
        "-approval")    color="\033[38;5;51m\033[1m";   signal="[?]"; shift; echo -e "${color}${signal} $*${RESETC}";;
        "-cancel")      color="\033[0;34m\033[1m";      signal="[!]"; shift; echo -e "${color}${signal} $*${RESETC}";;
        "-success")     color="\033[0;32m\033[1m";      signal="[+]"; shift; echo -e "${color}${signal} $*${RESETC}";;
        "-warning")     color="\033[0;33m\033[1m";      signal="[&]"; shift; echo -e "${color}${signal} $*${RESETC}";;
        "-error")       color="\033[0;31m\033[1m";      signal="[-]"; shift; echo -e "${color}${signal} $*${RESETC}";;
        *)              color="$RESETC";                signal=""; shift; echo -e "${color}${signal} $*${RESETC}";;
    esac
}

function man() {
    local normal='\e[0m'
    local bold_red='\e[1;31m'
    local highlight='\e[1;44;33m'
    local bold_green='\e[1;32m'
    
    env \
    LESS_TERMCAP_mb="$bold_red" \
    LESS_TERMCAP_md="$bold_red" \
    LESS_TERMCAP_me="$normal" \
    LESS_TERMCAP_se="$normal" \
    LESS_TERMCAP_so="$highlight" \
    LESS_TERMCAP_ue="$normal" \
    LESS_TERMCAP_us="$bold_green" \
    man "$@"
}

function extract-files() {
  # Extrae archivos comprimidos de forma autom√°tica seg√∫n la extensi√≥n
  # Uso: extract-files <archivo>
  # Soporta: tar.bz2, tar.gz, bz2, rar, gz, tar, tbz2, tgz, zip, Z, 7z
  # Retorna: 0 si √©xito, 1 si error
  
  if [[ $# -eq 0 ]]; then
    echo "Uso: extract-files <archivo>"
    return 1
  fi
  
  if [[ ! -f "$1" ]]; then
    echo "Error: '$1' no es un archivo v√°lido o no existe"
    return 1
  fi
  
  local file="$1"
  local filename
  filename="$(basename "$file")"
  
  # Validar que el archivo no sea peligroso
  if [[ "$file" =~ \.\./|\.\.\\|~[/\\]|\$ ]]; then
    echo "Error: Path no permitido: $file"
    return 1
  fi
  
  echo "Extrayendo: $filename"
  
  case "$file" in
    *.tar.bz2) 
      if command -v tar >/dev/null 2>&1; then
        tar xvjf "$file"
      else
        echo "Error: tar no est√° instalado"
        return 1
      fi
      ;;
    *.tar.gz) 
      if command -v tar >/dev/null 2>&1; then
        tar xvzf "$file"
      else
        echo "Error: tar no est√° instalado"
        return 1
      fi
      ;;
    *.bz2) 
      if command -v bunzip2 >/dev/null 2>&1; then
        bunzip2 "$file"
      else
        echo "Error: bunzip2 no est√° instalado"
        return 1
      fi
      ;;
    *.rar) 
      if command -v unrar >/dev/null 2>&1; then
        unrar x "$file"
      else
        echo "Error: unrar no est√° instalado"
        return 1
      fi
      ;;
    *.gz) 
      if command -v gunzip >/dev/null 2>&1; then
        gunzip "$file"
      else
        echo "Error: gunzip no est√° instalado"
        return 1
      fi
      ;;
    *.tar) 
      if command -v tar >/dev/null 2>&1; then
        tar xvf "$file"
      else
        echo "Error: tar no est√° instalado"
        return 1
      fi
      ;;
    *.tbz2) 
      if command -v tar >/dev/null 2>&1; then
        tar xvjf "$file"
      else
        echo "Error: tar no est√° instalado"
        return 1
      fi
      ;;
    *.tgz) 
      if command -v tar >/dev/null 2>&1; then
        tar xvzf "$file"
      else
        echo "Error: tar no est√° instalado"
        return 1
      fi
      ;;
    *.zip) 
      if command -v unzip >/dev/null 2>&1; then
        unzip "$file"
      else
        echo "Error: unzip no est√° instalado"
        return 1
      fi
      ;;
    *.Z) 
      if command -v uncompress >/dev/null 2>&1; then
        uncompress "$file"
      else
        echo "Error: uncompress no est√° instalado"
        return 1
      fi
      ;;
    *.7z) 
      if command -v 7z >/dev/null 2>&1; then
        7z x "$file"
      else
        echo "Error: 7z no est√° instalado"
        return 1
      fi
      ;;
    *) 
      echo "Error: No s√© c√≥mo extraer '$filename'"
      echo "Formatos soportados: tar.bz2, tar.gz, bz2, rar, gz, tar, tbz2, tgz, zip, Z, 7z"
      return 1
      ;;
  esac
}

function mkt() {
  # Crea estructura de directorios para pentesting
  # Uso: mkt
  # Crea: nmap, content, exploits, scripts
  mkdir {nmap,content,exploits,scripts}
}

function cdl() { 
  # Cambia de directorio y lista contenido
  # Uso: cdl [directorio]
  cd "$@" && ls; 
}

function cmkdir() {
  # Crea directorio y entra en √©l
  # Uso: cmkdir <nombre-directorio>
  if [[ -z "$1" ]]; then
    message -warning "Uso: cmkdir <nombre-directorio>"
    return 1
  fi
  mkdir "$1" || return 1
  cd "$1" || return 1
}

function rmk() {
  # Elimina archivos/directorios de forma segura
  # Uso: rmk <archivo|directorio>
  # Usa shred si est√° disponible para borrado seguro
  if [[ -z "$1" ]] || [[ ! -e "$1" ]]; then
    message -error "Uso: rmk <archivo|directorio>"
    return 1
  fi
  
  # Validar path seguro
  if [[ "$1" =~ \.\./|\.\.\\|~[/\\]|\$ ]]; then
    message -error "Path no permitido: $1"
    return 1
  fi
  
  # Usar shred como m√©todo est√°ndar para sobrescribir archivos
  if command -v shred >/dev/null 2>&1; then
    shred -zun 10 -v "$1"
  else
    message -warning "shred no est√° disponible, usando rm normal"
    rm -rf "$1"
  fi
}

function extract-ports() {
    if [ -z "$1" ] || [ ! -f "$1" ]; then
        message -error "Usage: extract-ports <nmap-file>"
        return 1
    fi
    
    ports="$(cat "$1" | grep -oP '\d{1,5}/open' | awk '{print $1}' FS='/' | xargs | tr ' ' ',')"
    ip_address="$(cat "$1" | grep -oP '\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}' | sort -u | head -n 1)"
    
    echo -e "\n[*] Extracting information...\n" > extractPorts.tmp
    echo -e "\t[*] IP Address: $ip_address" >> extractPorts.tmp
    echo -e "\t[*] Open ports: $ports\n" >> extractPorts.tmp
    
    # Copiar a clipboard solo si xclip est√° disponible
    if command -v xclip &>/dev/null; then
        echo $ports | tr -d '\n' | xclip -sel clip
        echo -e "[*] Ports copied to clipboard\n" >> extractPorts.tmp
    else
        message -warning "xclip no est√° disponible (puertos no copiados)"
    fi
    
    cat extractPorts.tmp
    rm -f extractPorts.tmp
}

function open-file() {
    local file=$1
    if [ -z "$EDITOR" ]; then
        message -warning "La variable EDITOR no est√° definida."
    else
        case "$EDITOR" in
            code|vim|nano)
                $EDITOR "$file"
            ;;
            *)
                message -error "Editor no soportado: $EDITOR."
            ;;
        esac
    fi
}

function venv-create() {
    # Crea un entorno virtual Python con nombre basado en el directorio actual
    # Uso: venv-create
    local dir_name
    dir_name="$(basename "$(pwd)")"
    local env_name
    env_name="$(echo "$dir_name" | tr '[:upper:]' '[:lower:]' | iconv -f utf8 -t ascii//TRANSLIT)"
    env_name=".$env_name-env"
    
    python3 -m venv "$env_name"
    if [[ $? -ne 0 ]]; then
        message -error "Failed to create virtual environment."
        return 1
    fi
    
    source "$env_name/bin/activate"
    if [[ $? -ne 0 ]]; then
        message -error "Failed to activate virtual environment."
        return 1
    fi
    
    message -success "Virtual environment '$env_name' created and activated."
}

function get-venv-name() {
    # Obtiene el nombre del entorno virtual basado en el directorio actual
    # Uso: get-venv-name
    local dir_name
    dir_name="$(basename "$(pwd)")"
    echo -e ".$(echo "$dir_name" | tr '[:upper:]' '[:lower:]' | iconv -f utf8 -t ascii//TRANSLIT)-env"
}

function settarget(){
    # Usar XDG Base Directory specification
    local xdg_config="${XDG_CONFIG_HOME:-$HOME/.config}"
    local htb_config_dir="$xdg_config/rofi/htb"
    local target_file="$htb_config_dir/mark-name"
    
    # Validar entrada de IP (b√°sica)
    local ip_pattern='^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$'
    local ip_arg="$1"
    local name_arg="${2:-}"
    
    # Validar n√∫mero de argumentos
    if [[ $# -eq 0 ]] || [[ $# -gt 2 ]]; then
        message -error "Uso: settarget <IP> [NAME] | settarget <IP>"
        return 1
    fi
    
    # Validar formato de IP
    if [[ ! "$ip_arg" =~ $ip_pattern ]]; then
        message -error "Formato de IP inv√°lido: $ip_arg"
        return 1
    fi
    
    # Validar octetos de IP
    IFS='.' read -ra ADDR <<< "$ip_arg"
    for octet in "${ADDR[@]}"; do
        if [[ "$octet" -gt 255 ]] || [[ "$octet" -lt 0 ]]; then
            message -error "Octeto de IP inv√°lido: $octet (debe ser 0-255)"
            return 1
        fi
    done
    
    # Validar nombre (si se proporciona)
    if [[ -n "$name_arg" ]]; then
        # Permitir solo alfanum√©ricos, guiones y guiones bajos
        if [[ ! "$name_arg" =~ ^[a-zA-Z0-9_-]+$ ]]; then
            message -error "Nombre inv√°lido: $name_arg (solo alfanum√©ricos, guiones y guiones bajos)"
            return 1
        fi
        
        # Validar longitud
        if [[ ${#name_arg} -gt 50 ]]; then
            message -error "Nombre demasiado largo: $name_arg (m√°ximo 50 caracteres)"
            return 1
        fi
    fi
    
    # Validar que la estructura de directorios existe
    if [[ ! -d "$htb_config_dir" ]]; then
        message -info "Creando directorio de configuraci√≥n: $htb_config_dir"
        mkdir -p "$htb_config_dir" || {
            message -error "No se pudo crear $htb_config_dir"
            return 1
        }
    fi
    
    # Validar que podemos escribir en el archivo
    if ! touch "$target_file" 2>/dev/null; then
        message -error "No se puede escribir en: $target_file"
        return 1
    fi
    
    # Guardar target
    if [[ -n "$name_arg" ]]; then
        echo "$ip_arg $name_arg" > "$target_file" || {
            message -error "Error al guardar target"
            return 1
        }
        message -success "Target asignado: $ip_arg ($name_arg)"
    else
        echo "$ip_arg" > "$target_file" || {
            message -error "Error al guardar target"
            return 1
        }
        message -success "Target asignado: $ip_arg"
    fi
    
    # Mostrar informaci√≥n del archivo
    message -info "Guardado en: $target_file"
    message -info "Configuraci√≥n XDG: $xdg_config"
}

function fzf-lovely(){
    # Validar que fzf est√© disponible
    if ! command -v fzf >/dev/null 2>&1; then
        message -error "fzf no est√° instalado. Inst√°lalo con: sudo apt install fzf"
        return 1
    fi
    
    # Funci√≥n optimizada para detectar si un archivo es binario
    is_binary() {
        local file="$1"
        # Usar file command con cach√© para mejor performance
        if command -v file >/dev/null 2>&1; then
            file -b --mime-type "$file" 2>/dev/null | grep -q "^binary/"
        else
            # Fallback: verificar caracteres nulos en primeros bytes
            [[ -f "$file" ]] && head -c 1024 "$file" 2>/dev/null | grep -q $'\0'
        fi
    }
    
    # Funci√≥n optimizada para previsualizaci√≥n con m√∫ltiples herramientas
    preview_content() {
        local file="$1"
        
        # Salida temprana para archivos binarios
        if is_binary "$file"; then
            echo "üìÅ Binary file: $(basename "$file")"
            return 0
        fi
        
        # Tama√±o m√°ximo para previsualizaci√≥n (100KB para evitar lentitud)
        local max_size=$((100 * 1024))
        local file_size
        file_size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo 0)
        
        if [[ $file_size -gt $max_size ]]; then
            echo "üìÑ File too large for preview ($(echo "scale=1; $file_size/1024" | bc)KB)"
            echo "First 5 lines:"
            head -5 "$file" 2>/dev/null
            return 0
        fi
        
        # Intentar diferentes herramientas en orden de preferencia
        local tool_used=""
        
        # bat (mejor opci√≥n con sintaxis)
        if command -v bat >/dev/null 2>&1; then
            if bat --style=numbers --color=always "$file" 2>/dev/null; then
                tool_used="bat"
            fi
        fi
        
        # highlight (alternativa)
        if [[ -z "$tool_used" ]] && command -v highlight >/dev/null 2>&1; then
            if highlight -O ansi -l "$file" 2>/dev/null; then
                tool_used="highlight"
            fi
        fi
        
        # coderay (otra alternativa)
        if [[ -z "$tool_used" ]] && command -v coderay >/dev/null 2>&1; then
            if coderay "$file" 2>/dev/null; then
                tool_used="coderay"
            fi
        fi
        
        # rougify (√∫ltima alternativa)
        if [[ -z "$tool_used" ]] && command -v rougify >/dev/null 2>&1; then
            if rougify "$file" 2>/dev/null; then
                tool_used="rougify"
            fi
        fi
        
        # cat como fallback final
        if [[ -z "$tool_used" ]]; then
            cat "$file" 2>/dev/null
        fi
    }
    
    # Construir comando de preview optimizado
    local preview_cmd='preview_content {} 2>/dev/null || echo "Error: Cannot preview file"'
    
    # Configuraci√≥n optimizada seg√∫n argumentos
    local fzf_opts=(
        "-m"  # Selecci√≥n m√∫ltiple
        "--preview" "$preview_cmd"
        "--preview-window" "down:20"  # Ventana m√°s peque√±a para mejor rendimiento
    )
    
    # Modo horizontal si se especifica "h"
    if [[ "$1" == "h" ]]; then
        fzf_opts+=("--reverse")
    fi
    
    # Opciones adicionales para mejor rendimiento
    fzf_opts+=(
        "--height" "40%"
        "--border"
        "--prompt" "üîç "
        "--pointer" "‚ñ∂"
        "--marker" "‚úì"
    )
    
    # Ejecutar fzf con opciones optimizadas
    fzf "${fzf_opts[@]}" 2>/dev/null
}

function cu() {
  # Navega hacia arriba N directorios
  # Uso: cu [n√∫mero-de-directorios]
  local count="${1:-1}"
  local path=""
  
  for i in $(seq 1 "$count"); do
    path="${path}../"
  done
  cd "$path" || return 1
}

function compile-pls() {
    # Validar argumentos de forma segura
    if [[ $# -eq 0 ]]; then
        message -cancel "Error: Debes proporcionar un archivo."
        return 1
    fi
    
    local input_file="$1"
    
    # Validar y sanitizar el path del archivo de entrada
    if [[ "$input_file" =~ \.\./|\.\.\\|~[/\\]|\$|\;|\|\||\&|\||\>|\< ]]; then
        message -cancel "Error: El path contiene caracteres no permitidos."
        return 1
    fi
    
    # Convertir a path absoluto de forma segura
    local abs_file
    abs_file="$(realpath -m "$input_file" 2>/dev/null)" || {
        message -cancel "Error: Path inv√°lido o inaccesible: $input_file"
        return 1
    }
    
    # Verificar que el archivo existe, es regular y es legible
    if [[ ! -f "$abs_file" ]] || [[ ! -r "$abs_file" ]]; then
        message -cancel "Error: El archivo '$input_file' no existe o no es legible."
        return 1
    }
    
    # Extraer componentes del nombre de archivo de forma segura
    local filename
    filename="$(basename "$abs_file")"
    
    # Validar que el nombre de archivo no contenga caracteres peligrosos
    if [[ ! "$filename" =~ ^[a-zA-Z0-9._-]+\.[a-zA-Z0-9._-]+$ ]]; then
        message -cancel "Error: Nombre de archivo no v√°lido: $filename"
        return 1
    fi
    
    local extension="${filename##*.}"
    local name_without_ext="${filename%.*}"
    
    # Validar extensi√≥n conocida
    case "$extension" in
        kt|java|cpp|c|pas)
            # Extensiones v√°lidas
            ;;
        *)
            message -cancel "Error: Extensi√≥n de archivo no admitida: .$extension"
            return 1
            ;;
    esac
    
    # Validar nombre de salida (sin espacios ni caracteres especiales)
    if [[ ! "$name_without_ext" =~ ^[a-zA-Z0-9._-]+$ ]]; then
        message -cancel "Error: Nombre de archivo base no v√°lido: $name_without_ext"
        return 1
    fi
    
    # Cambiar al directorio del archivo para evitar problemas de path
    local original_dir
    original_dir="$(pwd)"
    local file_dir
    file_dir="$(dirname "$abs_file")"
    
    cd "$file_dir" || {
        message -cancel "Error: No se puede acceder al directorio del archivo."
        return 1
    }
    
    # Funci√≥n para limpiar en caso de error
    local cleanup_needed=false
    cleanup_on_error() {
        if [[ "$cleanup_needed" == true ]]; then
            # Limpiar archivos temporales generados
            rm -f "${name_without_ext}.class" "${name_without_ext}.o" "${name_without_ext}.jar" 2>/dev/null
        fi
        cd "$original_dir"
    }
    
    trap cleanup_on_error EXIT ERR
    
    case "$extension" in
        "kt")
            if ! command -v kotlinc >/dev/null 2>&1 || ! command -v java >/dev/null 2>&1; then
                message -cancel "Error: Kotlin o Java no est√°n instalados."
                return 1
            fi
            cleanup_needed=true
            if kotlinc "$filename" -include-runtime -d "${name_without_ext}.jar" 2>/dev/null; then
                java -jar "${name_without_ext}.jar"
            else
                message -cancel "Error: Fall√≥ la compilaci√≥n de Kotlin."
                return 1
            fi
            ;;
        "java")
            if ! command -v javac >/dev/null 2>&1 || ! command -v java >/dev/null 2>&1; then
                message -cancel "Error: Java no est√° instalado."
                return 1
            fi
            cleanup_needed=true
            if javac "$filename" 2>/dev/null; then
                java "$name_without_ext"
            else
                message -cancel "Error: Fall√≥ la compilaci√≥n de Java."
                return 1
            fi
            ;;
        "cpp")
            if ! command -v g++ >/dev/null 2>&1; then
                message -cancel "Error: g++ no est√° instalado."
                return 1
            fi
            cleanup_needed=true
            if g++ "$filename" -o "$name_without_ext" 2>/dev/null; then
                "./$name_without_ext"
            else
                message -cancel "Error: Fall√≥ la compilaci√≥n de C++."
                return 1
            fi
            ;;
        "c")
            if ! command -v gcc >/dev/null 2>&1; then
                message -cancel "Error: gcc no est√° instalado."
                return 1
            fi
            cleanup_needed=true
            if gcc "$filename" -o "$name_without_ext" 2>/dev/null; then
                "./$name_without_ext"
            else
                message -cancel "Error: Fall√≥ la compilaci√≥n de C."
                return 1
            fi
            ;;
        "pas")
            if ! command -v fpc >/dev/null 2>&1; then
                message -cancel "Error: Free Pascal Compiler (fpc) no est√° instalado."
                return 1
            fi
            cleanup_needed=true
            if fpc "$filename" 2>/dev/null; then
                "./$name_without_ext"
            else
                message -cancel "Error: Fall√≥ la compilaci√≥n de Pascal."
                return 1
            fi
            ;;
    esac
    
    # Marcar que no hay error para que el cleanup no se ejecute
    cleanup_needed=false
    cd "$original_dir"
}


function initialize-git-repo() {
    local repo_name=""
    local readme_message="Proyecto inicializado"
    local remote_url=""
    local branch="main"
    local dir="$(pwd)"

    while getopts "n:m:r:b:" opt; do
        case "$opt" in
            n) repo_name="$OPTARG" ;;       # Nombre del repositorio (obligatorio)
            m) readme_message="$OPTARG" ;;  # Mensaje para el README.md (opcional)
            r) remote_url="$OPTARG" ;;      # URL del repositorio remoto (opcional)
            b) branch="$OPTARG" ;;          # Rama a la que se har√° push (opcional)
            \?) message -error "Uso: initialize-git-repo -n <repo_name> [-m <readme_message>] [-r <remote_url>] [-b <branch>]"
            return 1 ;;
        esac
    done
    
    if [[ -z "$repo_name" ]]; then
        message -error "Error: Debes proporcionar un nombre para el repositorio con -n."
        return 1
    fi

    mkdir -p "$repo_name" && cd "$repo_name" || return 1
    
    git init >/dev/null 2>&1
    echo -e ".vscode/" > .gitignore
    echo "# $repo_name" > README.md
    echo "$readme_message" >> README.md

    git add .
    git commit -m "Initial commit" >/dev/null 2>&1
    
    if [[ -n "$remote_url" ]]; then
        git remote add origin "$remote_url"
        git branch -M "$branch"
        git push -u origin "$branch" || message -warning "No se pudo hacer push al repositorio remoto"
    fi
    
    cd "$dir"
    message -success "Repositorio '$repo_name' inicializado correctamente."
}

function tell-me-a-joke() {
	curl -sSL https://v2.jokeapi.dev/joke/Any | jq -r '.category, .type, .joke, .setup, .delivery'
}

function pray-for-me() {
    curl -s https://bible-api.deno.dev/api/books/newTestament | jq
}

function cheat() {
    local search=$1
	curl -s "cheat.sh/$search" | cat
}

function wttr() {
    local idioma="es"
    local opciones="2mp"
    local ubicacion="Santiago+de+chile"
    curl -s "wttr.in/$ubicacion?$opciones&lang=$idioma"
}

function crypto-rate() {
	curl -s "https://rate.sx/?qF&n=10"
}

function calc () {
    local operation=$1
    echo "$operation" | bc -ql
}

function gen_gitignore() {
    local API_BASE="https://www.toptal.com/developers/gitignore/api"
    local LIST_URL="${API_BASE}/list"
    local OUTFILE=".gitignore"

    # Si no se pasan par√°metros
    if [[ $# -eq 0 ]]; then
        echo "Uso: gen_gitignore <templates...>"
        echo "Ej: gen_gitignore python,node,linux"
        echo "Opciones:"
        echo "  --list   Listar templates disponibles"
        return 0
    fi

    # Si piden listar
    if [[ "$1" == "--list" ]]; then
        if command -v curl &>/dev/null; then
            curl -sL "$LIST_URL"
        elif command -v wget &>/dev/null; then
            wget -qO- "$LIST_URL"
        else
            echo "Instala curl o wget para usar esta funci√≥n."
            return 1
        fi
        return 0
    fi

    # Construir URL de petici√≥n
    local templates="$*"
    local url="${API_BASE}/${templates}"

    # Obtener el contenido
    local content
    if command -v curl &>/dev/null; then
        content=$(curl -sL "$url")
    elif command -v wget &>/dev/null; then
        content=$(wget -qO- "$url")
    else
        echo "Instala curl o wget para usar esta funci√≥n."
        return 1
    fi

    # Si ya existe .gitignore
    if [[ -f "$OUTFILE" ]]; then
        read -p ".gitignore ya existe. ¬øAgregar (a), Sobrescribir (s) o Cancelar (c)? [a/s/c]: " choice
        case "$choice" in
            [Aa]* )
                printf "\n# Agregado por gen_gitignore: %s\n" "$templates" >> "$OUTFILE"
                printf "%s\n" "$content" >> "$OUTFILE"
                echo "Contenido agregado a $OUTFILE"
                ;;
            [Ss]* )
                printf "# Sobrescrito por gen_gitignore: %s\n%s\n" "$templates" "$content" > "$OUTFILE"
                echo "$OUTFILE sobrescrito"
                ;;
            * )
                echo "Cancelado."
                ;;
        esac
    else
        printf "# Generado por gen_gitignore: %s\n%s\n" "$templates" "$content" > "$OUTFILE"
        echo "$OUTFILE creado con plantillas: $templates"
    fi
}
