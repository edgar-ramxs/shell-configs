#!/bin/sh

# ============================================================================
# FUNCIONES PESADAS - Cargadas bajo demanda (Lazy Loading)
# ============================================================================
#
# Este archivo contiene funciones que no son usadas frecuentemente
# o que tienen cierta complejidad computacional.
#
# Son cargadas bajo demanda usando lazy_load_function() de lib.sh
# para mejorar el tiempo de inicio del shell.

# ============================================================================
# FUNCIONES DE COMPILACIÓN
# ============================================================================

function compile-pls() {
    if [[ -z "$1" ]]; then
        echo "[-] Error: Debes proporcionar un archivo."
        return 1
    fi
    
    if [[ ! -f "$1" ]]; then
        echo "[-] Error: El archivo '$1' no existe."
        return 1
    fi
    
    local filename=$(basename "$1")
    local extension="${filename##*.}"
    local name_without_ext="${filename%.*}"
    
    command_exists() {
        command -v "$1" >/dev/null 2>&1
    }
    
    case "$extension" in
        "kt")
            if command_exists kotlinc && command_exists java; then
                kotlinc "$filename" -include-runtime -d "${name_without_ext}.jar" && java -jar "${name_without_ext}.jar"
            else
                echo "[-] Error: Kotlin o Java no están instalados."
                return 1
            fi
        ;;
        "java")
            if command_exists javac && command_exists java; then
                javac "$filename" && java "$name_without_ext"
            else
                echo "[-] Error: Java no está instalado."
                return 1
            fi
        ;;
        "cpp")
            if command_exists g++; then
                g++ "$filename" -o "$name_without_ext" && "./$name_without_ext"
            else
                echo "[-] Error: g++ no está instalado."
                return 1
            fi
        ;;
        "c")
            if command_exists gcc; then
                gcc "$filename" -o "$name_without_ext" && "./$name_without_ext"
            else
                echo "[-] Error: gcc no está instalado."
                return 1
            fi
        ;;
        "rs")
            if command_exists rustc; then
                rustc "$filename" -o "$name_without_ext" && "./$name_without_ext"
            else
                echo "[-] Error: rustc no está instalado."
                return 1
            fi
        ;;
        "go")
            if command_exists go; then
                go run "$filename"
            else
                echo "[-] Error: Go no está instalado."
                return 1
            fi
        ;;
        *)
            echo "[-] Extensión no soportada: $extension"
            return 1
        ;;
    esac
}

# ============================================================================
# FUNCIONES DE BÚSQUEDA AVANZADA
# ============================================================================

function fzf-lovely() {
    if [ "$1" = "h" ]; then
        fzf -m --reverse --preview-window down:20 --preview '[[ $(file --mime {}) =~ binary ]] &&
 	                echo {} is a binary file ||
	                 (bat --style=numbers --color=always {} ||
	                  highlight -O ansi -l {} ||
	                  coderay {} ||
	                  rougify {} ||
        cat {}) 2> /dev/null | head -500'
        
    else
        fzf -m --preview '[[ $(file --mime {}) =~ binary ]] &&
	                         echo {} is a binary file ||
	                         (bat --style=numbers --color=always {} ||
	                          highlight -O ansi -l {} ||
	                         coderay {} ||
	                          rougify {} ||
        cat {}) 2> /dev/null | head -500'
    fi
}

# ============================================================================
# FUNCIONES DE ANÁLISIS Y UTILIDADES
# ============================================================================

function extract-ports() {
	ports="$(cat $1 | grep -oP '\d{1,5}/open' | awk '{print $1}' FS='/' | xargs | tr ' ' ',')"
	ip_address="$(cat $1 | grep -oP '\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}' | sort -u | head -n 1)"
	echo -e "\n[*] Extracting information...\n" > extractPorts.tmp
	echo -e "\t[*] IP Address: $ip_address"  >> extractPorts.tmp
	echo -e "\t[*] Open ports: $ports\n"  >> extractPorts.tmp
	echo $ports | tr -d '\n' | xclip -sel clip
	echo -e "[*] Ports copied to clipboard\n"  >> extractPorts.tmp
	cat extractPorts.tmp; rm extractPorts.tmp
}

# ============================================================================
# FUNCIONES DE RED Y UTILIDADES API
# ============================================================================

function tell-me-a-joke() {
	curl -sSL https://v2.jokeapi.dev/joke/Any | jq -r '.category, .type, .joke, .setup, .delivery'
}

function pray-for-me() {
    curl -s https://bible-api.deno.dev/api/books/newTestament | jq
}

function cheat() {
    local search=$1
	curl -s "cheat.sh/$search" | cat
}

function wttr() {
    local idioma="es"
    local opciones="2mp"
    local ubicacion="Santiago+de+chile"
    curl -s "wttr.in/$ubicacion?$opciones&lang=$idioma"
}

function crypto-rate() {
	curl -s "https://rate.sx/?qF&n=10"
}

# ============================================================================
# FUNCIONES DE GIT
# ============================================================================

function initialize-git-repo() {
  # Inicializa un repositorio git con configuración básica
  # Uso: initialize-git-repo -n <nombre> [-m <mensaje>] [-r <remote>] [-b <branch>]
  local dir="$(pwd)"
  local repo_name=""
  local remote_url=""
  local branch="main"
  local readme_message=""

  while getopts "n:r:b:m:" opt; do
    case $opt in
      n) repo_name="$OPTARG" ;;      # Nombre del repositorio
      r) remote_url="$OPTARG" ;;     # URL del repositorio remoto (opcional)
      b) branch="$OPTARG" ;;         # Rama a la que se hará push (opcional)
      m) readme_message="$OPTARG" ;; # Mensaje para el README.md (opcional)
      \?) echo "Uso: initialize-git-repo -n <repo_name> [-m <readme_message>] [-r <remote_url>] [-b <branch>]"
        return 1 ;;
    esac
  done
  
  if [[ -z "$repo_name" ]]; then
    echo "Error: Debes proporcionar un nombre para el repositorio con -n."
    return 1
  fi

  mkdir -p "$repo_name" && cd "$repo_name" || return 1
  
  git init >/dev/null 2>&1
  echo -e ".vscode/" > .gitignore
  echo "# $repo_name" > README.md
  echo "$readme_message" >> README.md

  git add .
  git commit -m "Initial commit" >/dev/null 2>&1
  
  if [[ -n "$remote_url" ]]; then
    git remote add origin "$remote_url"
    git branch -M "$branch"
    git push -u origin "$branch"
  fi
  
  cd "$dir"
  echo "Repositorio '$repo_name' inicializado correctamente."
}

# ============================================================================
# FUNCIONES DE CÁLCULO
# ============================================================================

function calc() {
    local operation=$1
    echo "$operation" | bc -ql
}
