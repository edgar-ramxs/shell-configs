#!/usr/bin/env bash
#    ‚ñà‚ñà‚ïó     ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó
#    ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïî‚ïù
#    ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù 
#    ‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó  ‚ïö‚ñà‚ñà‚ïî‚ïù  
#    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   
#    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïù   

# Este archivo contiene funciones comunes que pueden ser utilizadas por
# m√∫ltiples scripts en el proyecto. Incluye funciones para mensajes con
# colores, limpieza de recursos y utilidades diversas.

# ============================================================================
# DEFINICI√ìN DE COLORES (si no est√°n definidos)
# ============================================================================

[[ -z "${WHITE:-}"   ]] && readonly WHITE='\033[0;37m'
[[ -z "${MAGENTA:-}" ]] && readonly MAGENTA='\033[0;35m'
[[ -z "${CYAN_B:-}"  ]] && readonly CYAN_B='\033[38;5;51m'
[[ -z "${BLUE:-}"    ]] && readonly BLUE='\033[0;34m'
[[ -z "${GREEN:-}"   ]] && readonly GREEN='\033[0;32m'
[[ -z "${YELLOW:-}"  ]] && readonly YELLOW='\033[0;33m'
[[ -z "${RED:-}"     ]] && readonly RED='\033[0;31m'
[[ -z "${BOLD:-}"  ]] && readonly BOLD='\033[1m'
[[ -z "${RESET:-}" ]] && readonly RESET='\033[0m'

# ============================================================================
# FUNCI√ìN: message
# ============================================================================
# Imprime mensajes formateados con colores y se√±ales visuales
#
# Tipos de mensaje:
#   -title       Encabezado principal (cian, negrita)
#   -subtitle    Encabezado secundario (azul, negrita)
#   -success     Mensaje de √©xito (verde, negrita)
#   -warning     Mensaje de advertencia (amarillo, negrita)
#   -error       Mensaje de error (rojo, negrita)
#   -info        Informaci√≥n (cian sin negrita)
#   (default)    Texto normal
#
# Ejemplo:
#   message -title "INICIANDO PROCESO"
#   message -success "Operaci√≥n completada"
#   message -error "Error: archivo no encontrado"

message() {
    local signal color
    case "$1" in
        -title)     color="${WHITE}${BOLD}";    signal="[‚Üí]"; shift; echo -e "\n${color}${signal} $*${RESET}";;
        -subtitle)  color="${MAGENTA}${BOLD}";  signal="[*]"; shift; echo -e "${color}${signal} $*${RESET}";;
        -approval)  color="${CYAN_B}${BOLD}";   signal="[?]"; shift; echo -e "${color}${signal} $*${RESET}";;
        -info)      color="${CYAN_B}";          signal="[i]"; shift; echo -e "${color}${signal} $*${RESET}";;
        -cancel)    color="${BLUE}${BOLD}";     signal="[!]"; shift; echo -e "${color}${signal} $*${RESET}";;
        -warning)   color="${YELLOW}${BOLD}";   signal="[&]"; shift; echo -e "\t${color}${signal} $*${RESET}";;
        -success)   color="${GREEN}${BOLD}";    signal="[+]"; shift; echo -e "\t${color}${signal} $*${RESET}";;
        -error)     color="${RED}${BOLD}";      signal="[-]"; shift; echo -e "\t${color}${signal} $*${RESET}";;
        *)          echo -e "$*";;
    esac
}


# ============================================================================
# FUNCI√ìN: check_command_exists
# ============================================================================
# Verifica si un comando est√° disponible en el sistema
#
# Argumentos:
#   $1: Nombre del comando a verificar
#
# Retorno:
#   0: Comando encontrado
#   1: Comando no encontrado
#
# Ejemplo:
#   if check_command_exists "git"; then
#       message -success "Git est√° disponible"
#   fi

check_command_exists() {
    command -v "$1" &> /dev/null
}

# ============================================================================
# FUNCI√ìN: check_file_exists
# ============================================================================
# Verifica si un archivo existe
#
# Argumentos:
#   $1: Ruta del archivo
#
# Retorno:
#   0: Archivo existe
#   1: Archivo no existe
#
# Ejemplo:
#   if check_file_exists "/path/to/file"; then
#       message -info "El archivo existe"
#   fi

check_file_exists() {
    [[ -f "$1" ]]
}

# ============================================================================
# FUNCI√ìN: check_dir_exists
# ============================================================================
# Verifica si un directorio existe
#
# Argumentos:
#   $1: Ruta del directorio
#
# Retorno:
#   0: Directorio existe
#   1: Directorio no existe
#
# Ejemplo:
#   if check_dir_exists "/path/to/dir"; then
#       message -info "El directorio existe"
#   fi

check_dir_exists() {
    [[ -d "$1" ]]
}

# ============================================================================
# FUNCI√ìN: ensure_dir
# ============================================================================
# Crea un directorio si no existe
#
# Argumentos:
#   $1: Ruta del directorio
#
# Retorno:
#   0: Directorio creado o ya existe
#   1: Error al crear
#
# Ejemplo:
#   ensure_dir "$HOME/.config/shell/backups"

ensure_dir() {
    local dir="$1"
    if [[ ! -d "$dir" ]]; then
        mkdir -p "$dir" || return 1
        message -success "Directorio creado: $dir"
    fi
    return 0
}

# ============================================================================
# FUNCI√ìN: safe_copy_with_backup
# ============================================================================
# Copia un archivo haciendo backup del existente
#
# Argumentos:
#   $1: Archivo origen
#   $2: Archivo destino
#   $3: Directorio de backup (opcional)
#
# Retorno:
#   0: Copia exitosa
#   1: Error en la copia
#
# Ejemplo:
#   safe_copy_with_backup "$HOME/config" "$HOME/.config/shell/config" "$HOME/.config/shell/backups"

safe_copy_with_backup() {
    local source="$1"
    local dest="$2"
    local backup_dir="${3:-.}"
    
    if [[ ! -e "$source" ]]; then
        message -error "Archivo de origen no existe: $source"
        return 1
    fi
    
    # Si el destino existe, hacer backup
    if [[ -e "$dest" ]]; then
        local backup_name="$(basename "$dest")_$(date +%Y%m%d_%H%M%S)"
        local backup_path="${backup_dir}/${backup_name}"
        
        ensure_dir "$backup_dir" || return 1
        cp "$dest" "$backup_path" || return 1
        message -info "Backup creado: $backup_path"
    fi
    
    # Copiar el nuevo archivo
    cp "$source" "$dest" || return 1
    message -success "Archivo copiado: $dest"
    
    return 0
}

# ============================================================================
# FUNCI√ìN: validate_bash_syntax
# ============================================================================
# Valida la sintaxis bash de un archivo
#
# Argumentos:
#   $1: Ruta del archivo
#
# Retorno:
#   0: Sintaxis v√°lida
#   1: Errores de sintaxis
#
# Ejemplo:
#   if validate_bash_syntax "$script"; then
#       message -success "Script v√°lido"
#   fi

validate_bash_syntax() {
    local file="$1"
    
    if [[ ! -f "$file" ]]; then
        message -error "Archivo no encontrado: $file"
        return 1
    fi
    
    if bash -n "$file" 2>/dev/null; then
        return 0
    else
        message -error "Error de sintaxis bash en: $file"
        bash -n "$file"
        return 1
    fi
}

# ============================================================================
# FUNCI√ìN: print_separator
# ============================================================================
# Imprime un separador visual
#
# Argumentos:
#   $1: Car√°cter a usar (opcional, default: =)
#   $2: Ancho (opcional, default: 80)
#
# Ejemplo:
#   print_separator
#   print_separator "-" 60

print_separator() {
    local char="${1:-=-}"
    local width="${2:-80}"
    
    printf '%*s\n' "$width" | tr ' ' "$char"
}

# ============================================================================
# FUNCI√ìN: get_timestamp
# ============================================================================
# Obtiene un timestamp formateado
#
# Argumentos:
#   $1: Formato (opcional, default: %Y%m%d_%H%M%S)
#
# Ejemplo:
#   ts=$(get_timestamp)
#   ts=$(get_timestamp "%Y-%m-%d %H:%M:%S")

get_timestamp() {
    local format="${1:-%Y%m%d_%H%M%S}"
    date +"$format"
}

# ============================================================================
# FUNCI√ìN: confirm
# ============================================================================
# Pide confirmaci√≥n al usuario
#
# Argumentos:
#   $1: Mensaje de confirmaci√≥n
#
# Retorno:
#   0: Usuario confirm√≥ (s/S/y/Y)
#   1: Usuario cancel√≥ (n/N/q/Q o Ctrl+C)
#
# Ejemplo:
#   if confirm "¬øDeseas continuar?"; then
#       message -info "Continuando..."
#   fi

confirm() {
    local prompt="${1:-¬øContinuar?}"
    local response
    
    echo -ne "${BOLD}${CYAN}[?]${RESET} ${prompt} (s/n): "
    read -r response
    
    case "$response" in
        [sS]|[yY]|[sS][√≠i]) return 0 ;;
        *) return 1 ;;
    esac
}

# ============================================================================
# FUNCI√ìN: cleanup_temp_files
# ============================================================================
# Funci√≥n base para limpieza de archivos temporales
# Debe ser sobrescrita en scripts que crean archivos temporales
#
# Ejemplo:
#   cleanup_temp_files() {
#       [[ -n "${TEMP_LOG:-}" ]] && rm -f "$TEMP_LOG"
#   }
#   trap cleanup_temp_files EXIT

cleanup_temp_files() {
    # Funci√≥n vac√≠a, ser√° sobrescrita si es necesaria
    :
}

# ============================================================================
# FUNCI√ìN: find_first_available_command
# ============================================================================
# Busca y retorna el primer comando disponible de una lista
#
# Argumentos:
#   Nombres de comandos a buscar (m√∫ltiples argumentos)
#
# Retorno:
#   Ruta del primer comando encontrado
#   (vac√≠o si ninguno est√° disponible)
#
# Ejemplo:
#   editor=$(find_first_available_command vim nano vi)
#   echo "Using editor: $editor"

find_first_available_command() {
    local cmd
    for cmd in "$@"; do
        if check_command_exists "$cmd"; then
            command -v "$cmd"
            return 0
        fi
    done
    return 1
}

# ============================================================================
# FUNCI√ìN: find_first_available_directory
# ============================================================================
# Busca y retorna el primer directorio disponible de una lista
#
# Argumentos:
#   Rutas de directorios a buscar (m√∫ltiples argumentos)
#
# Retorno:
#   Ruta del primer directorio encontrado
#   (vac√≠o si ninguno existe)
#
# Ejemplo:
#   config_dir=$(find_first_available_directory ~/.config ~/.etc /etc/myapp)
#   echo "Using config: $config_dir"

find_first_available_directory() {
    local dir
    for dir in "$@"; do
        if check_dir_exists "$dir"; then
            echo "$dir"
            return 0
        fi
    done
    return 1
}

# ============================================================================
# FUNCI√ìN: deduplicate_path
# ============================================================================
# Elimina duplicados en PATH manteniendo el orden
#
# Argumentos:
#   $1: Variable PATH a limpiar (por defecto: $PATH)
#
# Retorno:
#   PATH sin duplicados
#
# Ejemplo:
#   PATH=$(deduplicate_path "$PATH")

deduplicate_path() {
    local path="${1:-$PATH}"
    echo "$path" | tr ':' '\n' | awk '!a[$0]++' | paste -sd: -
}

# ============================================================================
# FUNCI√ìN: lazy_load_function
# ============================================================================
# Carga funciones grandes bajo demanda para mejorar tiempo de inicio
#
# Esta funci√≥n crea un "stub" que carga la funci√≥n real la primera vez
# que se ejecuta, mejorando el tiempo de inicio del shell.
#
# Argumentos:
#   $1: Nombre de la funci√≥n a cargar bajo demanda
#   $2: Archivo fuente con la funci√≥n
#
# Ejemplo:
#   lazy_load_function "compile-pls" "$HOME/.config/shell/functions-heavy"
#   lazy_load_function "fzf-lovely" "$HOME/.config/shell/functions-heavy"

lazy_load_function() {
    local func_name="$1"
    local source_file="$2"
    
    # Validaci√≥n de entrada
    if [[ -z "$func_name" ]] || [[ -z "$source_file" ]]; then
        message -error "lazy_load_function: funci√≥n o archivo no especificado"
        return 1
    fi
    
    # Sanitizar nombre de funci√≥n (solo permitir alfanum√©ricos, guiones y guiones bajos)
    if [[ ! "$func_name" =~ ^[a-zA-Z][a-zA-Z0-9_-]*$ ]]; then
        message -error "lazy_load_function: nombre de funci√≥n inv√°lido: $func_name"
        return 1
    fi
    
    # Validar y normalizar path (prevenir directory traversal)
    local normalized_file
    normalized_file=$(realpath "$source_file" 2>/dev/null) || {
        message -error "lazy_load_function: path inv√°lido: $source_file"
        return 1
    }
    
    # Verificar que el archivo existe y es legible
    if [[ ! -f "$normalized_file" ]] || [[ ! -r "$normalized_file" ]]; then
        message -warning "lazy_load_function: archivo no encontrado o no legible: $normalized_file"
        return 1
    fi
    
    # Verificar que es un archivo seguro (dentro del proyecto)
    local project_root
    project_root=$(realpath "$(dirname "${BASH_SOURCE[0]}")/.." 2>/dev/null) || {
        message -error "lazy_load_function: no se puede determinar el project root"
        return 1
    }
    
    if [[ ! "$normalized_file" == "$project_root"* ]]; then
        message -error "lazy_load_function: archivo fuera del proyecto: $normalized_file"
        return 1
    fi
    
    # Crear un "stub" seguro que carga la funci√≥n real cuando se ejecuta
    eval '
    '"$func_name"'() {
        # Descargar el stub
        unset -f '"$func_name"'
        # Cargar la funci√≥n real
        source "'"$normalized_file"'"
        # Ejecutar la funci√≥n con los argumentos originales
        '"$func_name"' "$@"
    }
    '
}

# ============================================================================
# FUNCI√ìN: is_command_available
# ============================================================================
# Versi√≥n mejorada de check_command_exists con caching
#
# Cachea resultados en /tmp para evitar m√∫ltiples b√∫squedas
#
# Argumentos:
#   $1: Nombre del comando a verificar
#
# Retorno:
#   0: Comando encontrado
#   1: Comando no encontrado
#
# Ejemplo:
#   if is_command_available "fzf"; then
#       enable_fzf_features
#   fi

is_command_available() {
    local cmd="$1"
    local cache_file="/tmp/.shell-cmd-cache-${cmd}"
    
    # Usar cache si existe y es reciente (menos de 1 hora)
    if [[ -f "$cache_file" ]]; then
        local cache_age=$(($(date +%s) - $(stat -c %Y "$cache_file" 2>/dev/null || echo 0)))
        if [[ $cache_age -lt 3600 ]]; then
            return $(cat "$cache_file")
        fi
    fi
    
    # Verificar comando y cachear resultado
    if command -v "$cmd" &>/dev/null; then
        echo "0" > "$cache_file"
        return 0
    else
        echo "1" > "$cache_file"
        return 1
    fi
}

# ============================================================================
# FUNCI√ìN: clear_command_cache
# ============================================================================
# Limpia la cach√© de comandos con opciones granulares
#
# Argumentos:
#   $1: Patr√≥n a limpiar (opcional, por defecto todos)
#   $2: Forzar limpieza (opcional, --force para ignorar edad)
#
# Ejemplo:
#   clear_command_cache              # Limpia toda la cach√©
#   clear_command_cache "git"       # Limpia solo cache de comandos git*
#   clear_command_cache "" --force   # Fuerza limpieza de toda la cach√©

clear_command_cache() {
    local pattern="${1:-*}"
    local force_clean="$2"
    local cache_dir="/tmp"
    local cleaned=0
    local total_size=0
    
    # Buscar archivos de cache
    while IFS= read -r -d '' cache_file; do
        local basename=$(basename "$cache_file")
        
        # Verificar si coincide con el patr√≥n
        if [[ "$pattern" != "*" ]] && [[ ! "$basename" =~ ^\.shell-cmd-cache-${pattern} ]]; then
            continue
        fi
        
        # Si no es force, verificar edad (solo limpiar si es mayor a 1 hora)
        if [[ "$force_clean" != "--force" ]]; then
            local cache_age=$(($(date +%s) - $(stat -c %Y "$cache_file" 2>/dev/null || echo 0)))
            if [[ $cache_age -lt 3600 ]]; then
                continue
            fi
        fi
        
        # Acumular tama√±o antes de eliminar
        local file_size=$(stat -c%s "$cache_file" 2>/dev/null || echo 0)
        total_size=$((total_size + file_size))
        
        rm -f "$cache_file"
        ((cleaned++))
    done < <(find "$cache_dir" -name ".shell-cmd-cache-*" -type f -print0 2>/dev/null)
    
    if [[ $cleaned -gt 0 ]]; then
        message -success "Cache limpiada: $cleaned archivos liberados (${total_size} bytes)"
    else
        message -info "No se encontraron archivos de cache para limpiar"
    fi
}

# ============================================================================
# FUNCI√ìN: get_cache_stats
# ============================================================================
# Muestra estad√≠sticas de uso de la cach√© de comandos
#
# Argumentos:
#   Ninguno
#
# Ejemplo:
#   get_cache_stats

get_cache_stats() {
    local cache_dir="/tmp"
    local total_files=0
    local total_size=0
    local old_files=0
    
    while IFS= read -r -d '' cache_file; do
        local file_size=$(stat -c%s "$cache_file" 2>/dev/null || echo 0)
        local cache_age=$(($(date +%s) - $(stat -c %Y "$cache_file" 2>/dev/null || echo 0)))
        
        ((total_files++))
        total_size=$((total_size + file_size))
        
        if [[ $cache_age -gt 3600 ]]; then
            ((old_files++))
        fi
    done < <(find "$cache_dir" -name ".shell-cmd-cache-*" -type f -print0 2>/dev/null)
    
    echo "üìä Estad√≠sticas de Cach√©:"
    echo "   Archivos totales: $total_files"
    echo "   Tama√±o total: $((total_size / 1024))KB"
    echo "   Archivos antiguos (>1h): $old_files"
    
    if [[ $old_files -gt 0 ]]; then
        echo "   üí° Ejecuta 'clear_command_cache' para limpiar archivos antiguos"
    fi
}

# ============================================================================
# FUNCI√ìN: validate_directory_exists
# ============================================================================
# Valida existencia de m√∫ltiples directorios en PATH
#
# Argumentos:
#   Directorios a validar (m√∫ltiples argumentos)
#
# Retorno:
#   0: Al menos uno existe
#   1: Ninguno existe
#
# Ejemplo:
#   if validate_directory_exists "$HOME/.local/bin" "/usr/local/bin"; then
#       message -success "Directorios v√°lidos encontrados"
#   fi

validate_directory_exists() {
    for dir in "$@"; do
        [[ -d "$dir" ]] && return 0
    done
    return 1
}

# ============================================================================
# FUNCI√ìN: get_package_manager_commands
# ============================================================================
# Obtiene los comandos del gestor de paquetes seg√∫n la distribuci√≥n
#
# Argumentos:
#   $1: Distribuci√≥n (ubuntu, debian, arch, manjaro, fedora, rhel)
#
# Retorno:
#   Exporta variables: PKG_UPDATE_CMD, PKG_INSTALL_CMD, PKG_CHECK_CMD
#
# Ejemplo:
#   get_package_manager_commands "ubuntu"
#   eval "$PKG_INSTALL_CMD git"

get_package_manager_commands() {
    local distro="$1"
    
    case "$distro" in
        ubuntu|debian)
            export PKG_UPDATE_CMD="sudo apt update -qq"
            export PKG_INSTALL_CMD="sudo apt install -y"
            export PKG_CHECK_CMD="dpkg -l"
            ;;
        arch|manjaro)
            export PKG_UPDATE_CMD="sudo pacman -Sy --noconfirm"
            export PKG_INSTALL_CMD="sudo pacman -S --noconfirm"
            export PKG_CHECK_CMD="pacman -Q"
            ;;
        fedora|rhel)
            export PKG_UPDATE_CMD="sudo dnf check-update"
            export PKG_INSTALL_CMD="sudo dnf install -y"
            export PKG_CHECK_CMD="dnf list installed"
            ;;
        *)
            message -error "Distribuci√≥n no soportada: $distro"
            return 1
            ;;
    esac
    
    return 0
}

# ============================================================================
# FUNCI√ìN: check_packages_array
# ============================================================================
# Verifica disponibilidad de un array de paquetes
#
# Argumentos:
#   $1: Distribuci√≥n
#   $2: Array de paquetes (pasado por nombre)
#
# Retorno:
#   0: Todos los paquetes est√°n disponibles
#   1: Al menos un paquete falta
#   Exporta variable: MISSING_PACKAGES[] con paquetes faltantes
#
# Ejemplo:
#   packages=("git" "curl" "jq")
#   if check_packages_array "ubuntu" packages; then
#       message -success "Todos los paquetes disponibles"
#   else
#       message -warning "Paquetes faltantes: ${MISSING_PACKAGES[*]}"
#   fi

check_packages_array() {
    local distro="$1"
    local -n packages_ref="$2"
    MISSING_PACKAGES=()
    
    # Obtener comandos del gestor de paquetes
    get_package_manager_commands "$distro" || return 1
    
    # Verificar cada paquete
    for pkg in "${packages_ref[@]}"; do
        if command -v "$pkg" >/dev/null 2>&1; then
            message -success "$pkg -> disponible"
        else
            message -warning "$pkg -> no encontrado"
            MISSING_PACKAGES+=("$pkg")
        fi
    done
    
    # Retornar 0 si todos est√°n disponibles, 1 si faltan
    [[ ${#MISSING_PACKAGES[@]} -eq 0 ]]
}

# ============================================================================
# FUNCI√ìN: install_packages_array
# ============================================================================
# Instala un array de paquetes seg√∫n la distribuci√≥n
#
# Argumentos:
#   $1: Distribuci√≥n
#   $2: Array de paquetes (pasado por nombre)
#   $3: Omitir actualizaci√≥n (opcional, default: false)
#
# Retorno:
#   0: Todos los paquetes instalados exitosamente
#   1: Al menos un paquete fall√≥
#   Exporta variables: SUCCESSFUL_PACKAGES[], FAILED_PACKAGES[]
#
# Ejemplo:
#   packages=("git" "curl" "jq")
#   if install_packages_array "ubuntu" packages; then
#       message -success "Instalaci√≥n completada"
#   fi

install_packages_array() {
    local distro="$1"
    local -n packages_ref="$2"
    local skip_update="${3:-false}"
    SUCCESSFUL_PACKAGES=()
    FAILED_PACKAGES=()
    
    # Validar que hay paquetes para instalar
    [[ ${#packages_ref[@]} -eq 0 ]] && {
        message -info "No hay paquetes para instalar"
        return 0
    }
    
    # Obtener comandos del gestor de paquetes
    get_package_manager_commands "$distro" || return 1
    
    # Obtener permisos sudo una sola vez
    message -warning "Se requieren permisos de sudo"
    local sudo_attempt=0
    while (( sudo_attempt < 3 )); do
        sudo -n true 2>/dev/null || sudo true && break
        ((sudo_attempt++))
        sleep 1
    done

    if (( sudo_attempt >= 3 )); then
        message -error "No se pudieron obtener permisos de sudo"
        return 1
    fi
    message -success "Permisos de sudo obtenidos"
    
    # Actualizar repositorios si no se omite
    if [[ "$skip_update" != "true" ]]; then
        message -subtitle "Actualizando repositorios..."
        if ! eval "$PKG_UPDATE_CMD" &>/dev/null; then
            message -error "Error actualizando repositorios"
            return 1
        fi
    fi
    
    # Instalar paquetes
    message -subtitle "Instalando paquetes..."
    for pkg in "${packages_ref[@]}"; do
        # Verificar si ya est√° instalado
        if command -v "$pkg" >/dev/null 2>&1 || eval "$PKG_CHECK_CMD $pkg" &>/dev/null; then
            message -success "$pkg -> ya disponible"
            SUCCESSFUL_PACKAGES+=("$pkg")
            continue
        fi
        
        message -info "Instalando: $pkg"
        if eval "$PKG_INSTALL_CMD $pkg" &>/dev/null; then
            # Verificar que se instal√≥ correctamente
            if command -v "$pkg" &>/dev/null || eval "$PKG_CHECK_CMD $pkg" &>/dev/null; then
                message -success "‚úì Instalado: $pkg"
                SUCCESSFUL_PACKAGES+=("$pkg")
            else
                message -error "‚úó Instalado pero no detectable: $pkg"
                FAILED_PACKAGES+=("$pkg")
            fi
        else
            message -error "‚úó Fall√≥: $pkg"
            FAILED_PACKAGES+=("$pkg")
        fi
        sleep 1
    done
    
    # Resumen
    [[ ${#SUCCESSFUL_PACKAGES[@]} -gt 0 ]] && \
        message -success "Paquetes instalados: ${SUCCESSFUL_PACKAGES[*]}"

    if [[ ${#FAILED_PACKAGES[@]} -gt 0 ]]; then
        message -warning "Paquetes que fallaron: ${FAILED_PACKAGES[*]}"
        return 1
    fi

    return 0
}

# ============================================================================
# CONFIGURACI√ìN DE TRAP
# ============================================================================

trap cleanup_temp_files EXIT

# ============================================================================
# FIN DE LA LIBRER√çA
# ============================================================================
