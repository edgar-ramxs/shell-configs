#!/bin/sh
#    ███████╗██╗   ██╗███╗   ██╗ ██████╗████████╗██╗ ██████╗ ███╗   ██╗███████╗
#    ██╔════╝██║   ██║████╗  ██║██╔════╝╚██╔══╝██║██╔═══██╗████╗  ██║██╔════╝
#    █████╗  ██║   ██║██╔██╗ ██║██║        ██║   ██║██║   ██║██╔██╗ ██║███████╗
#    ██╔══╝  ██║   ██║██║╚██╗██║██║        ██║   ██║██║   ██║██║╚██╗██║╚════██║
#    ██║     ╚██████╔╝██║ ╚████║╚██████╗   ██║   ██║╚██████╔╝██║ ╚████║███████║
#    ╚═╝      ╚═════╝ ╚═╝  ╚═╝ ╚═════╝   ╚═╝   ╚═╝ ╚═════╝ ╚═╝  ╚═╝╚══════╝

# Obtener la ruta del directorio que contiene este archivo
source "$(dirname "${BASH_SOURCE[0]}")/library.sh"


function cdl (){ 
    cd "$@" && ls -la; 
}


function extract-files() {
    _lib_extract_archive "$@"
}


function open-file() {
    _lib_smart_open "$@"
}


function compile-pls() {
    _lib_compile_code "$@"
}


function calc() {
    _lib_simple_calc "$@"
}


function show_ascii() {
    local name="$1"
    local ascii_dir="${XDG_DATA_HOME:-"$HOME/.local/share"}/shells-configs/draws"
    
    _lib_validate_required_param "$name" "Uso: show_ascii <nombre_ascii>" || return 1
    
    clear
    _lib_validate_file_with_message "${ascii_dir}/${name}.txt" "Error: No se encontró ${name}.txt" || return 1
    
    /usr/bin/cat "${ascii_dir}/${name}.txt"
    tput civis
    read -n 1
    tput cnorm
}


function mkt(){
    if ! _lib_check_command_exists mkdir; then
        _lib_message -error "mkdir no está disponible"
        return 1
    fi
    
    mkdir -p {nmap,content,exploits,scripts} && \
        _lib_message -success "Estructura de directorios de pentesting creada"
}


function rmk() {
    local target="$1"
    
    _lib_validate_required_param "$target" "Uso: rmk <archivo_o_directorio>" || return 1
    _lib_validate_file_with_message "$target" "El archivo especificado no existe: $target" || return 1
    
    _lib_check_command_exists scrub || {
        _lib_message -error "scrub no está instalado. Instale con: sudo apt install scrub"
        return 1
    }
    
    _lib_check_command_exists shred || {
        _lib_message -error "shred no está disponible"
        return 1
    }
    
    _lib_confirm "¿Eliminar permanentemente '$target'? Esta acción es IRREVERSIBLE" || {
        _lib_message -cancel "Operación cancelada por el usuario"
        return 1
    }
    
    _lib_message -info "Eliminando permanentemente: $target"
    
    if scrub -p dod "$target" && shred -zun 10 -v "$target"; then
        _lib_message -success "Archivo eliminado permanentemente: $target"
        return 0
    else
        _lib_message -error "Error eliminando archivo: $target"
        return 1
    fi
}


function cmkdir() {
    local dir_name="$1"
    
    _lib_validate_required_param "$dir_name" "Uso: cmkdir <nombre-directorio>" || return 1
    
    if ! _lib_check_command_exists mkdir; then
        _lib_message -error "mkdir no está disponible"
        return 1
    fi
    
    if mkdir "$dir_name" 2>/dev/null; then
        _lib_message -success "Directorio creado: $dir_name"
    else
        _lib_message -error "Error creando directorio: $dir_name"
        return 1
    fi
}


function cudir() {
    local count="${1:-1}"
    
    if ! _lib_safe_numeric_input "$count" 1 20 "El número de directorios debe estar entre 1 y 20"; then
        _lib_message -info "Uso: cudir [numero_directorios] (default: 1, max: 20)"
        return 1
    fi
    
    if ! _lib_check_command_exists seq; then
        _lib_message -error "seq no está disponible"
        return 1
    fi
    
    local path=""
    for i in $(seq 1 $count); do
        path="${path}../"
    done
    
    cd "$path" || {
        _lib_message -error "Error navegando $count directorios hacia arriba"
        return 1
    }
    
    _lib_message -info "Navegado $count directorios hacia arriba"
}


function fetch() {
    local cmd=$(_lib_find_first_available_command fastfetch neofetch fetching zfetch)
    if [[ -n "$cmd" ]]; then
        "$cmd" "$@"
        return 0
    else
        _lib_message -error "No se encontró ningún comando de 'fetch'"
        return 1
    fi
}


function settarget(){
    _lib_validate_param_count $# 1 2 "Uso: settarget <IP> [NAME] | settarget <IP>" || return 1
    
    local target_dir="$HOME/.config/rofi/htb"
    local target_file="$target_dir/mark-name"
    
    _lib_ensure_dir "$target_dir" || {
        _lib_message -error "No se puede crear directorio: $target_dir"
        return 1
    }
    
    if [[ $# -eq 1 ]]; then
        echo "$1" > "$target_file" && \
            _lib_message -success "Target guardado: $1"
    else
        echo "$1 $2" > "$target_file" && \
            _lib_message -success "Target guardado: $1 ($2)"
    fi
}


function venv-create() {
    local dir_name
    local env_name="${1:-}"
    if [[ -z "$env_name" ]]; then
        dir_name=$(basename "$(pwd)")
        env_name=$(echo "$dir_name" | tr '[:upper:]' '[:lower:]' | iconv -f utf8 -t ascii//TRANSLIT 2>/dev/null || echo "$dir_name")
        env_name=".$env_name-env"
    fi
    
    if [[ -d "$env_name" ]]; then
        _lib_message -warning "El entorno virtual '$env_name' ya existe"
        return 1
    fi
    
    if ! _lib_check_command_exists python3; then
        _lib_message -error "Python 3 no está instalado"
        return 1
    fi
    
    _lib_message -info "Creando entorno virtual: $env_name"
    if ! python3 -m venv "$env_name"; then
        _lib_message -error "Falló la creación del entorno virtual"
        return 1
    fi
    
    _lib_message -success "Entorno virtual '$env_name' creado y activado"
    return 0
}


function get-venv-name() {
    local dir_name=$(basename "$(pwd)")
    _lib_normalize_text "$dir_name" "." "-env" "$dir_name"
}


function fzf-lovely(){
    _lib_check_command_exists fzf || {
        _lib_message -error "fzf no está instalado. Instale con: sudo apt install fzf"
        return 1
    }
    
    local preview_cmd='[[ $(file --mime {}) =~ binary ]] &&
                      echo {} is a binary file ||
                     (bat --style=numbers --color=always {} ||
                      highlight -O ansi -l {} ||
                      coderay {} ||
                      rougify {} ||
                      cat {}) 2> /dev/null | head -500'
    
    if [[ "$1" = "h" ]]; then
        fzf -m --reverse --preview-window down:20 --preview "$preview_cmd"
    else
        fzf -m --preview "$preview_cmd"
    fi
}


function extract-ports() {
    local input_file="$1"
    
    _lib_validate_required_param "$input_file" "Uso: extract-ports <archivo_nmap>" || return 1
    _lib_validate_file_with_message "$input_file" || return 1

    _lib_check_command_exists xclip || {
        _lib_message -error "xclip no está disponible"
        return 1
    }

    # Crear archivo temporal para el reporte
    local temp_file=$(_lib_create_temp_report "extract_ports" true)

    # local ports="$(cat $1 | grep -oP '\d{1,5}/open' | awk '{print $1}' FS='/' | xargs | tr ' ' ',')"
	# local ip_address="$(cat $1 | grep -oP '\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}' | sort -u | head -n 1)"
    local ports=$(_lib_extract_patterns "$input_file" '\d{1,5}/open' '/' ',')
    local ip_address=$(_lib_extract_patterns "$input_file" '\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}' ' ' ',' | head -n 1)

    # # Escribir reporte en archivo temporal
    # _lib_write_to_temp "$temp_file" "\n[*] Extracting information...\n" "overwrite"
    # _lib_write_to_temp "$temp_file" "\t[*] IP Address: $ip_address"
    # _lib_write_to_temp "$temp_file" "\t[*] Open ports: $ports\n"

    echo -e "\n[+] Extrayendo información desde: $input_file\n" > "$temp_file"
	echo -e "\n[+] Extracting information...\n" >> "$temp_file"
	echo -e "\t[*] IP Address: $ip_address"  >> "$temp_file"
	echo -e "\t[*] Open ports: $ports\n"  >> "$temp_file"
	echo -e "\n[+] Ports copied to clipboard\n"  >> "$temp_file"
    echo $ports | tr -d '\n' | xclip -sel clip
	cat "$temp_file"; rm "$temp_file"

    _lib_message -success "Análisis completado"
    return 0
}


function tell-me-a-joke() {
    local response category type joke setup delivery
    
    # Parsear los campos
    response=$(curl -sSL https://v2.jokeapi.dev/joke/Any)
    category=$(echo "$response" | jq -r '.category')
    type=$(echo "$response" | jq -r '.type')
    joke=$(echo "$response" | jq -r '.joke')
    setup=$(echo "$response" | jq -r '.setup')
    delivery=$(echo "$response" | jq -r '.delivery')
    
    # Imprimir la categoría
    echo "[$category]"
    echo
    
    # Imprimir según el tipo de chiste
    if [ "$type" = "single" ]; then
        echo "$joke"
    elif [ "$type" = "twopart" ]; then
        echo "$setup"
        echo "$delivery"
    fi
}


function pray-for-me() {
    local response book chapter verse text translation

    # Parsear los campos
    response=$(curl -s https://bible-api.com/data/web/random)
    translation=$(echo "$response" | jq -r '.translation.name')
    book=$(echo "$response" | jq -r '.random_verse.book')
    chapter=$(echo "$response" | jq -r '.random_verse.chapter')
    verse=$(echo "$response" | jq -r '.random_verse.verse')
    text=$(echo "$response" | jq -r '.random_verse.text')
    
    # Imprimir el versículo
    echo
    echo "[$book $chapter:$verse]"
    echo
    echo "$text"
    echo
}


function cheat() {
    local search=$1
	curl -s "cheat.sh/$search" | cat
}


function wttr() {
    local ubicacion="${1:-}"
    local url=$(_lib_build_api_url "https://wttr.in" "$ubicacion" "format=2mp" "lang=es")

    # local idioma="es"
    # local opciones="2mp"
    # local ubicacion="Santiago+de+chile"
    # curl -s "wttr.in/$ubicacion?$opciones&lang=$idioma"
}


function crypto-rate() {
	curl -s "https://rate.sx/?qF&n=10"
}


function initialize_git_repo() {
    # Validar que git esté disponible
    _lib_check_command_exists "git" || {
        _lib_message -error "git no está instalado"
        return 1
    }

    local dir="$(pwd)"
    local repo_name=""
    local remote_url=""
    local branch="main"
    local readme_message="proyecto inicializado"

    while getopts "n:m:r:b:" opt; do
        case "$opt" in
            n) repo_name="$OPTARG" ;;       # Nombre del repositorio (obligatorio)
            m) readme_message="$OPTARG" ;;  # Mensaje para el README.md (opcional)
            r) remote_url="$OPTARG" ;;      # URL del repositorio remoto (opcional)
            b) branch="$OPTARG" ;;          # Rama a la que se hará push (opcional)
            \?) _lib_message -error "Uso: initialize_git_repo -n <repo_name> [-m <readme_message>] [-r <remote_url>] [-b <branch>]"
                return 1 ;;
        esac
    done
    
    # Validar parámetro obligatorio usando función existente
    _lib_validate_required_param "$repo_name" "Debes proporcionar un nombre para el repositorio con -n" || return 1

    # Crear directorio usando función existente
    _lib_ensure_dir "$repo_name" || {
        _lib_message -error "No se pudo crear el directorio: $repo_name"
        return 1
    }

    cd "$repo_name" || {
        _lib_message -error "No se pudo acceder al directorio: $repo_name"
        return 1
    }

    # Inicializar repositorio
    _lib_message -info "Inicializando repositorio git..."
    git init >/dev/null 2>&1 || {
        _lib_message -error "Error al inicializar repositorio git"
        cd "$dir"
        return 1
    }

    # Crear archivos iniciales
    echo -e ".vscode/" > .gitignore
    echo "# $repo_name" > README.md
    echo "$readme_message" >> README.md

    # Commit inicial
    git add . >/dev/null 2>&1
    git commit -m "Initial commit" >/dev/null 2>&1 || {
        _lib_message -warning "No se pudo crear el commit inicial"
    }
    
    # Configurar remoto si se proporcionó
    if [[ -n "$remote_url" ]]; then
        _lib_message -info "Configurando repositorio remoto..."
        git remote add origin "$remote_url" || {
            _lib_message -warning "No se pudo agregar el remoto"
        }
        git branch -M "$branch"
        git push -u origin "$branch" || {
            _lib_message -warning "No se pudo hacer push al remoto"
        }
    fi
    
    cd "$dir"
    _lib_message -success "Repositorio '$repo_name' inicializado correctamente"
}

